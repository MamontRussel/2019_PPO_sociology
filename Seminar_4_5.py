'''
Семинар 4 (Недели 4-5 на Coursera)
Сегодня мы разберем материал недель 4 и 5: функции, кортежи, списки, цикл for.
'''

'''
РАСПАКОВКА
Распаковка в питоне используется для разделения последовательностей 
(списки, кортежи) в другие переменные. Часто возникает необходимость извлечь 
из последовательности элементы и присвоить каждый из них определённой переменной. 
Для этого стоит использовать следующую конструкцию:
'''

test_list = ['Аркадий', 'Паровозов', 27]
name, surname, age = test_list
print(name, surname, age)

'''
Очевидный минус данного подхода состоит в том, что нам нужно знать 
точное количество элементов в списке. Для того, чтобы это избежать - используется оператор *:
'''

# Данная конструкция формирует последовательность из 10 элементов,
# но переменных для распаковки указано всего две.
# Тогда, а будет содержать первый элемент, а b - оставшуюся часть последовательности
a, *b = range(10)
print(a, b)

'''
Распаковка хороша для написания функций с неизвестным заранее количеством параметров (*args и **kwargs).
Распаковка позволяет удобно менять местами две переменные (без использования третьей промежуточной):
a, b = b, a
'''

a, b = 1, 2
print(a, b)
a, b = b, a
print(a, b)


'''
МЕТОДЫ SPLIT И JOIN
Метод split позволяет разрезать строку (string) на отдельные слова ("токены"). 
В качестве разделителя может выступать пробел, символ табуляции или перевода строки.
Этот метод не изменяет строку и возвращает список строк-токенов. Особенно удобен для того, чтобы
считывать input для задач из одной строки. Метод join работает в обратную сторону
'''

str1 = 'This is a string'  # По умолчанию разбивка идет по пробелу.
lst = str1.split()
print(lst)
str2 = 'This is, a string'  # По умолчанию разбивка идет по пробелу.
lst = str2.split(',')  # Передали параметр для критерия разбивки
print(lst)

# ввели несколько чисел и сохранили их в список
numList = list(map(int, input().split('Input numbers for a list: ')))

# Применяем метод к параметру, который хотим вставить между токенами и передаем список как аргумент
print('--'.join(lst))

'''
ФУНКЦИИ
Мы, начиная с 1-го занятия, активно используем функции - например print.
Сегодня мы научимся создавать функции самостоятельно.
По своей сути функция - это часть программы, которая может выполняться
с разными параметрами и необходимость в исполнении которой возникает регулярно.
(вспомните print - мы регулярно испытываем необходимость вывести что-то - то число, то строку,
то результат каких-то наших действий - на консоль)

Когда нам понадобятся свои функции?
а) Когда какой-то кусочек (блок) программы нам надо будет выполнить несколько
раз (чтобы не прописывать его каждый раз полностью, а вместо этого вызывать функцию)
б) когда наша программа очень большая, мы можем какие-то ее части (блоки) оформлять
в виде функции, чтобы было легче разобраться в этой программе

Изучим создание функций на примере создания функции для подсчета факториала
Напомним, что факториал - это произведение первых n значений: 
4! = 1 * 2 * 3 * 4
'''

'''
сперва просто создадим код для расчета факториала любого числа n
'''

n = int(input('Number here: '))

# создаем переменную fact, которая будет равна факториалу заданного числа.
# На первом шаге присваем ей значение 1, потому что и 0! и 1! равные единице
# (это для случая если введем n = 0 или 1)
fact = 1

# создаем цикл для расчета факториала
i = 2
while i <= n:
    fact *= i
    i += 1
print(fact)

'''
Теперь создадим функцию,куда вынесем расчет факториала
'''
# def - команда, определяющая функцию. В ней указываем имя определяемой функции (factorial)
# и в скобках имя ее параметра (num). В конце обязательно ставим двоеточие.


def factorial(num): # с помощью num мы просто показываем, сколько параметров мы будем передавать функции
    fact = 1
    i = 2
    while i <= num:
        fact *= i
        i += 1
    return fact      # return это команда прекращения работы функции и возвращения ее результат


n = int(input('Your number here: '))     # вводим число, чей факториал мы хотим рассчитать
print(factorial(n))                      # вызываем только что созданную функцию

''' Функции могут иметь много аргументов/параметров, и в качестве таковых
могут выступать константные значения (одно или несколько), переменные
(одна или несколько) и результаты вычисления арифметических
выражений и исполнения других функций
(вспомним все ту же функцию print, какие разные вещи мы записывали в ее аргумент)
'''

'''
Команда return, как мы помним, завершает исполнение функции, возвращая ее значение
Если у нас несколько аругментов, то мы можем прописать в команде return возвращение
нескольких значений, или каждого значения в каком-то своем месте функции - в зависимости от наших потребностей

Примеры:
Вычисление максимума:'''


def max1(a, b):
    if a > b:
        return a
    else:
        return b


def max2(a, b, c):
    return max1(max1(a, b), c)


print(max1(5, 8))
print(max2(5, 8, 10))

'''
Функция может принимать и возвращать несколько значений.
Например, напишем функцию, которая сравнивает a и b и сортирует их.
'''


def sort2(a, b):
    if a < b:
        return a, b
    else:
        return b, a


number1 = int(input('number1: '))
number2 = int(input('number2: '))

# можем "распаковать" вывод функций и присвоить два значения -
# двум переменным
minimum, maximum = sort2(number1, number2)

print(minimum, maximum)

''' Глобальные и локальные переменные
Если переменная задается вне тела функции - это глобальная переменная,
она "видна" и может использоваться в любом месте программного кода
Если же переменная задается внутри тела функции - это локальная переменная
которая существует только внутри функции.
Сравним
'''


def f():
    x = 1


f()
print(x)  # выдает ошибку, потому что для скрипта вне функции перменной x не существует


def f():
    global x  # объявляем переменную x - глобальной, она сохранится и вне функции.
    x = 1


f()
print(x)

'''
Не всегда мы знаем, сколько параметров примет функция. Для этого у нас заданный параметр *args,
который представляет из себя список (подробнее об этом ниже), который распаковывается по ходу исполнения функции.
'''


def mySum(*args):
    numSum = 0
    for number in args:
        numSum += number
    return numSum


print(mySum(1, 2))
print(mySum(1, 2, 3, 4))

'''
КОРТЕЖИ, СПИСКИ
Списки в языке Python - аналог массивов в других языках программирования. 
Cписок может содержать внутри себя данные разных типов (например, целые числа и строки)
Задаётся оператором [] или функцией list().
Пример - список строк: ['string1', 'string2', 'string3']
или - список целых чисел: [1, 2, 3, 4, 5]
[1, 2, 'a', 'testphrase'] - смешанный список.
Список - это изменяемый тип данных. Это значит, что при редактировании списка, изменения вносятся в него же.
'''

example_list = [1, 2, 3, 4, 5]  # Создаём список целых чисел
print(example_list)


'''
Как и в случае со строками, элементы списка нумеруются, начиная с 0. 
Доступ к определенному элементу можно получить, зная его номер.
'''

example_element = example_list[0]
print(example_element)

print(example_list[0])
print(example_list[-1])  # Последний элемент в списке

'''
Кортежи (tuples):
Кортеж - аналог списка. В отличие от последнего, кортеж является неизменяемым и может, 
как и список, хранить внутри себя разные типы данных.
Кортеж создаётся с помощью () или функции tuple()
'''

example_tuple = (1, 2, 3, 'abc')  # Отличие от списка заключается в круглых скобках
print(example_tuple)

'''
Всё, перечисленное выше для списка верно и для кортежа:
'''

print(example_tuple)
print(example_tuple[0])

'''
Списки и кортежи могут быть вложенными, тогда для выбора элемента можно применять двойную и более индексацию.
'''

lst3 = [1, 2, ['all', 'fine', ['b', 'c']]]
print(lst3)
print(lst3[2])
print(lst3[2][1])
print(lst3[2][2][1])

'''
Также по индексу можно перезаписать значение элемента.
'''

lst3[2] = 'new element'
print(lst3)

'''
Списки и кортежи поддерживают операцию среза (доступ к какой-либо части элементов):
Срез производится при помощи двоеточия.
'''

slice_from_list = example_list[:1]  # Взяли один элемент слева
print(slice_from_list)
slice_from_tuple = example_tuple[:1]  # То же самое верно и для кортежа
print(slice_from_tuple)

'''
Немного экспериментов со срезами:
'''

print(example_list[1:])   # Все элементы, кроме первого
print(example_list[:-1])  # Все элементы, кроме последнего
print(example_list[-1:])  # Последний элемент
print(example_list[1:4])  # Элементы между первым и четвёртым (включая его!)

'''
Срезы можно выполнять с некоторым шагом между элементами:
'''

very_long_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
print(very_long_list[1:10:2])  # Все элементы со второго по десятый (включая его) с шагом в 2 элемета между ними

'''
Также можно делать преобразования типов с помощью tuple и list. Например:
'''

print(type((1, 2, 3)))
print(type([1, 2, 3]))
print(type(list((1, 2, 3))))
print(type(tuple([1, 2, 3])))

'''
ЦИКЛ FOR
Каноничное использование цикла for - повторение некоторых действий заданное количество раз.
Одако, в Python намного более распространено использование цикла for для итерации по элементам списка, 
кортежа, строки и т.д. Расмотрим следующую конструкцию:
'''

for number in range(10):
    print(number)

'''
range(10) возвращает нам последовательность из 10-ти целых чисел, идущих по порядку (начинаются с 0), 
и по которым можно итерироваться, переменная number хранит в себе текущий элемент списка, который, затем, 
выводится на экран. С каждй итерацией цикла, внутри number будет находиться текущий элемент последовательности.
Следует обратить внимание на отступ перед print внутри цикла (как это было для условий if else).
'''

'''
Чаще всего, цикл for используется для последовательного достпа к элементам списков, 
кортежей, строк или иных объектов, являющихся итерируемыми
'''

# Здесь вместо range, мы указали питону на уже существующий список very_long_list
print(very_long_list)
for element in very_long_list:
    print(element)

'''
Еще примеры.
'''

for number in very_long_list:
    print(2 * number)

for character in 'spam':
    print(character.upper())

'''
Эксперименты с range:
'''

print(list(range(1, 5)))  # Можно обозначить начало и конец требуемой последовательности
print(list(range(1, 10, 3)))  # и шаг между элементами, с которым она будет генерироваться


'''
ФУНКЦИЯ MAP
принимает два аргумента - функцию, которую хотим применить, и данные, к которым хотим ее принменить.
Мы могли бы использовать цикл for, но map более эффективна.
'''
# применяем функцию len() ко всем элементам списка и возвращаем результат.
lst1 = []
for element in ['red', 'green', 'blue']:
    lst1.append(len(element))
lst2 = list(map(len, ['red', 'green', 'blue']))
print(lst1)
print(lst2)

# применяем функцию max(), которая возвращает самое большое число или самую позднюю букву алфавита
# ко всем элементам списка. min() работает наоборот.
print(list(map(max, ['red', 'green', 'blue'])))
print(list(map(min, ['red', 'green', 'blue'])))

'''
Также вы часто будете встречаться с так называемыми анонимными или лямбда функциями.
Они нам нужны в тех случаях, когда нам надо применить какую-нибудь простую функцию (например,
возведение в куб) к ряду элементов, а используем мы ее не больше одного раза.
Две функции ниже - аналоги.
'''


def cube(num):
    return(num**3)
# lambda num: num**3


# обе функции можем использовать для map()
print(list(map(cube, [2, 3, 5])))
print(list(map(lambda num: num**3, [2, 3, 5])))




