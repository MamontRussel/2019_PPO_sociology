'''
Недели 5-9 Сoursera.
Чтение файлов, множества, словари, обработка ошибок, дополнительные методы работы со строками.
'''

'''
МЕТОДЫ РАБОТЫ СО СПИСКАМИ
Списки в Python поддерживают множество методов для взаимодействия с ними. 
Стоит отметить, что эти методы изменяют исходный список.
'''

test_list = list(range(10))
print(test_list)

# Добавляет в список указанный элемент (в конец)
test_list.append(11)
print(test_list)

# Сформируем другой список
sublist = [12, 12]
# И добавим его в существующий (в конец)
test_list.extend(sublist)
print(test_list)

# Добавим в список строку "ABC" на позицию "1". Отличие от test_list[1] = 'ABC' в том, что сейчас элемент,
# стоявший под индексом 1 не перезапишется, а все элементы сдвинутся вправо.
test_list.insert(1, 'ABC')
print(test_list)

# Удалим из списка первое вхождение указанного элемента (по значению).
test_list.remove('ABC')
print(test_list)

# Найдём позицию указанного элемента в списке. Если элемент встречается несколько раз,
# то метод вернёт наименьшую позицию повторяющегося элемента.
print(test_list.index(12))

# Метод возвращает количество указанных элементов в списке
print(test_list.count(12))

# Метод возвращает элемент списка с указанным индексом и одновременно убирает его.
popped_element = test_list.pop(5)
print(popped_element)
print(test_list)

# Если индекс не указан - метод убирает последний элемент списка.
popped_element = test_list.pop()
print(popped_element)
print(test_list)

# Метод меняет порядок расположения элементов в списке на противоположный
test_list.reverse()
print(test_list)

'''
Отдельно следует рассказать про метод sort(). Метод производит сортировку списка.
Задачи сортировки - очень распространены в программировании. 
В общем случае, они сводятся к выстроению элементов списка в заданном порядке.
В Python есть встроенные методы для сортировки объектов для того, чтобы программист 
мог не усложнять себе задачу написанием алгоритма сортировки. 
Метод list.sort() - как раз, один из таких случаев.
'''

test_list = [5, 8, 1, 4, 3, 7, 2]
print(test_list)  # Элементы списка расположены в хаотичном порядке
test_list.sort()
print(test_list)  # Теперь элементы списка теперь расположены по возрастанию

'''
Таким образом, метод list.sort() упорядочил элементы списка test_list
Если нужно отсортировать элементы в обратном порядке, то можно использовать:
'''

test_list.sort(reverse=True)  # параметр reverse указывает на то, что нужно отсортировать список в обратном порядке
print(test_list)

'''
Следует обратить внимание, что метод list.sort() изменяет сам список, на котором его вызвали. 
Таким образом, при каждом вызове метода "sort()", наш список "test_list" изменяется. 
Это может быть удобно, если нам не нужно держать в памяти исходный список. 
Однако, в противном случае, или же - в случае неизменяемого типа данных (например, кортежа или строки) - 
этот метод не сработает. В таком случае, на помощь приходит встроенная в питон функция sorted()
'''

print(sorted(test_list))  # Сам список при сортировке не изменяется

'''
У функции sorted(), как и у метода list.sort() есть параметр key, 
с помощью которого можно указать функцию, которая будет применена к каждому элементу 
последовательности при сортировке.
'''
test_string = 'A string With upper AND lower cases'
print(sorted(test_string.split()))
print(sorted(test_string.split(), key=str.upper))

'''
Имеем строку из слов, начинающихся с заглавных и строчных букв. 
test_strng.split() формирует список из элементов строки, разделённых пробелом. 
Далее, функция "sorted()" уже сортирует этот список, меняя регистр всех входящих в него элементов на верхний.
'''

'''
Однако, в некоторых случаях, встроенных функций Python для сортировки недостаточно, 
и нужно реалиовать алгоритм самим. Поэтому, рассмотрим сортировку подсчётом (без использования sorted())
'''
list_to_sort = [1, 10, 32, 14, 2, 5, 3, 19, 14]
# Создаём пустой список длины, равной значению наибольшего элемента исходного списка + 1
counters = [0] * (max(list_to_sort) + 1)
for item in list_to_sort:
    counters[item] += 1
result = []
for item, count in enumerate(counters):
    result.extend([item] * count)
print(result)


'''
МНОЖЕСТВА
Еще одна важная структура данных в python - множества. Если вы знакомы с логикой или теорией множеств,
то это собрания уникальных элементов. Главное отличие множеств - то, что элемент в них может встречаться только
один раз (в отличие от списков и кортежей).
Создаются фигурными скобками или функцией set().
Множества часто используются, когда нам нужен перечень уникальных элементов (например, чтобы проверить,
если в данных ответ с определенным значением). Это экономит память хранения такого списка.
Множества могут содержать объекты разных типов, но только неизменяемые (числа, строки).
'''

set1 = (1, 2, 2, 3, 4, 4, 4, 5)
print(set1)
for element in [2, 3, 8]:
    print(element in set1)

'''
Множества можно сравнивать между собой. К традиционным операциям добавляются дополнительные.
'''

firstSet = {1, 2, 1, 3}
secondSet = {3, 2, 1}
print(firstSet == secondSet)  # Все элементы совпадают
print(firstSet != secondSet)  # Есть различные элементы
print(firstSet <= secondSet)  # Все элементы А входят в B
print(firstSet < secondSet)   # Все элементы А входят в Б и есть различные элементы

'''
Количество элементов можно так же узнать с помощью функции len()
'''

len(set1)

'''
Мы можем применять к множествам логические операции, чтобы смотреть имеют ли они общие или разные элементы.
'''

firstSet = {1, 2, 1, 3, 5, 9}
secondSet = {3, 2, 1, 4}
print(firstSet)
print(secondSet)
print(firstSet | secondSet)  # Объединение множеств
print(firstSet & secondSet)  # Пересечение множеств
print(firstSet - secondSet)  # Множество, элементы которого входят в A, но не входят в B
print(firstSet ^ secondSet)  # Элементы входят в A | B, но не входят в A & B

'''
СЛОВАРИ
Словарь - это такая структура данных, когда мы хотим хранить данные не по индексу, а чтобы какому-то
ключю соответствовало какое-то значение (например, как в телефонной книге). 
Ключом (именем в телефонной книге) может быть любой неизменяемый объект(число, строка), а значением - 
любой (в т.ч. список, словарь, кортеж).
Создать словарь можно с помощью фигурных скобок или функции dict(). Ниже обратите внимание на синтаксис.
'''

phone_book = {'Tanya': '243-352', 'Oleg': ['242-212', '242-251']}
print(phone_book)

'''
Словарь - неупорядоченная структура. Мы не можем обратиться к объекту по индексу, но зато можем по ключу.
'''

print(phone_book['Tanya'])

'''
Чтобы узнать, какие ключи (keys) или значения (values) есть в словаре - можно воспользоваться соответствующими
методами.
'''

print(phone_book.keys())
print(phone_book.values())
print(phone_book.items())  # возвращает объект с ключами и значениями, по которому можно итерироваться

'''
Мы можем вывести ключи и соответсвующие им значения с помощью цикла for
'''

for key in phone_book.keys():
    print(key, phone_book[key])

for key, value in phone_book.items():
    print(key, value)

'''
Добавлять пары ключ значение в словарь очень просто: это делается по аналогии со списками.
Удаление происходит с помощью функции del.
Также можем проверить наличие ключа в словаре.
'''

phone_book['Alex'] = '242-325'
phone_book['Tanya'] = '25321-311'  # перезаписываем значение
print(phone_book)
del phone_book['Oleg']
print(phone_book)
print('Oleg' in phone_book.keys())

'''
Словари очень удобно использовать для подсчета числа элементов.
Давайте попробуем открыть файл и решить небольшую задачку.
Мы открываем файл с помощью функции open(), которой передаем адрес файла, 
форму работы с файлом (только чтение r, запись w, запись и чтение r+) и кодировку
(utf8 в нашем случае). Этот файл загружается в память.
Затем мы можем загружать его по строкам.
'''

file = open('C://Users/Rogov/Desktop/romeo.txt', 'r', encoding='utf8')  # загружаем файл в память
lines = file.readlines()  # создаем объект, который при каждом обращении будет загружать новую строку в память

for line in lines:
    print(line)

'''
Давайте посчитаем, какие слова и как часто встрачаются в нашем файле. 
Создадим словарь, в котором ключом будет слово, а значением - количество раз, которое оно встречается.
'''
file = open('C://Users/Rogov/Desktop/romeo.txt', 'r', encoding='utf8')  # загружаем файл в память
lines = file.readlines()  # перезаписываем объект lines, потому что выше итератор дошел до конца и закончился
words = dict()  # создаем пустой словарь
for line in lines:  # итерируемся по строкам файла
    templst = list(map(lambda x: x.lower(), line.split()))  # cохраняем все слова из строки в список в нижнем регистре
    print(templst)
    for word in templst:  # итерируемся по списку, созданному на основе строки
        if word in words.keys():  # проверяем наличие ключа в словаре
            words[word] += 1      # если ключ в словаре - прибавляем 1
        else:
            words[word] = 1       # если такого ключа нет - сохраняем ключ со значением один
        print(word, words[word])

print(words)
print(words['pale'])

'''
МЕТОДЫ ДЛЯ РАБОТЫ СО СТРОКАМИ
Словари очень часто используются для работы с текстом, поэтому давайте посмотрим, какие еще методы для строк 
есть в Python
'''

# isalpha - проверяет, что все символы строки являются буквами.
print('Ask me a question!'.isalpha())
print('Ask'.isalpha())

# isdigit - проверяет, что все символы строки являются цифрами.
print('13242'.isdigit())

# isalnum - проверяет, что все символы строки являются буквами или цифрами.
print('Ask me a question!'.isalnum())
print('Ask232'.isalnum())

# islower - проверяет, что все символы строки являются маленькими (строчными) буквами.
print('ssk me a question!'.islower())

# isupper - проверяет, что все символы строки являются большими (заглавными, прописными) буквами.
print('ssk me a question!'.isupper())

# lstrip - обрезает все пробельные символы в начале строки.
print(' ssk me a question! ')
print(' ssk me a question! '.lstrip())

# rstrip - обрезает все пробельные символы в конце строки.
print(' ssk me a question! '.rstrip())

# strip - обрезает все пробельные символы в начале и конце строки.
print(' ssk me a question! '.strip())
